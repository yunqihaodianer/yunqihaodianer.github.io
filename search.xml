<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>sojson手动过反调</title>
      <link href="/2022/03/08/sojson%E6%89%8B%E5%8A%A8%E8%BF%87%E5%8F%8D%E8%B0%83/"/>
      <url>/2022/03/08/sojson%E6%89%8B%E5%8A%A8%E8%BF%87%E5%8F%8D%E8%B0%83/</url>
      
        <content type="html"><![CDATA[<h1 id="过deugger的两种方式"><a href="#过deugger的两种方式" class="headerlink" title="过deugger的两种方式"></a>过deugger的两种方式</h1><ol><li><p>右键设置条件断点false,但遇见大的js会很卡</p></li><li><p>跟进找到方法hook掉即可(推荐),hook代码如下:</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_0x219caa = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yunqihaodianer/picgo/img/image-20211102162101129.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yunqihaodianer/picgo/img/image-20211102162144788.png"></p><p>过掉之后发现过了几秒钟又会断下来,我们会想到定时器,这时候看到栈已经变化,点进来之后就会发现定时器</p><p><img src="https://cdn.jsdelivr.net/gh/yunqihaodianer/picgo/img/image-20211102162644784.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//setInterval(方法,延迟)</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> _0x6f3e7f = &#123;</span><br><span class="line">        <span class="string">&#x27;gZfZW&#x27;</span>: <span class="keyword">function</span> <span class="title function_">_0xb97aa5</span>(<span class="params">_0x3b4f59</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">_0x3b4f59</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    _0x6f3e7f[<span class="string">&#x27;gZfZW&#x27;</span>](_0x4f1a43); <span class="comment">//就是运行_0x4f1a43这个方法</span></span><br><span class="line">&#125;, <span class="number">0xfa0</span>);</span><br></pre></td></tr></table></figure><p>解决方法就是在倒数第二行下断点,hook掉_0x4f1a43方法,代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_0x4f1a43= <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br></pre></td></tr></table></figure><p>这时候我们把断点去掉就会发现不会再自动断点了,完美解决</p><h1 id="sojson本地过反调"><a href="#sojson本地过反调" class="headerlink" title="sojson本地过反调"></a>sojson本地过反调</h1><p>第一步 文本里的debugger全删掉</p><p>第二步 setInterval定时器代码删掉</p><p>处理完成后在头部加一个debugger开始分析代码</p><p>一步一步往下跟进发现正则和toString首先想到是不是防止格式化</p><p>发现这个方法返回的是false,如果返回true就不会卡死</p><p><img src="https://cdn.jsdelivr.net/gh/yunqihaodianer/picgo/img/image-20211102170329171.png"></p><p>两个方法</p><p>1.直接把返回改为true</p><p>2.把这一行的代码改为未格式化后的代码即可,代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;removeCookie&#x27;</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">return</span><span class="string">&#x27;dev&#x27;</span>;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yunqihaodianer/picgo/img/image-20211102170522648.png"></p><p>如果还是卡死再看一下是否有其他正则检测</p><p>定时器上面就是真实代码,真实代码上面是解密代码+检测</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">w, d</span>) &#123; </span><br><span class="line"></span><br><span class="line"> w.<span class="property">info</span> = <span class="string">&quot;这是一个一系列js操作。&quot;</span>; </span><br><span class="line"></span><br><span class="line"> d.<span class="property">warning</span> = <span class="string">&quot;如果您的JS里嵌套了PHP，JSP标签，等等其他非JavaScript的代码，请提取出来再加密。这个工具不能加密php、jsp等模版内容&quot;</span>; </span><br><span class="line"></span><br><span class="line"> d.<span class="property">intro</span> = <span class="string">&quot;本工具由 www.jsjiami.com 提供接口。&quot;</span>; </span><br><span class="line"></span><br><span class="line">&#125;)(<span class="variable language_">window</span>, <span class="variable language_">document</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安卓逆向笔记</title>
      <link href="/2022/03/08/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/08/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Kali命令"><a href="#Kali命令" class="headerlink" title="Kali命令"></a>Kali命令</h1><p>按日期排序 : <code>ls -alit</code></p><p>adb断开 : <code>adb disconnect</code></p><p>查看本机ip :  <code>curl ip.sb</code></p><p>查看文件 : <code>cat 文件</code></p><p>复制文件 : <code>mv 文件</code></p><p>创建文件夹 : <code>mkdir 文件夹</code></p><p>删除 :  <code>rm 文件</code></p><p>git下载 : <code>git clone</code></p><p>在每行的行首加上内容：<code>sed -i -e &#39;s/^/内容/&#39; file.txt </code></p><p>在每行的行末加上内容： <code>sed 10-i s/$/内容/ file.txt</code></p><p>编辑环境 : <code>nano ~/.bashrc</code></p><p>保持环境 : <code>source ~/.bashrc </code></p><p>查看文件夹大小：<code>du -h --max-depth=1</code><br>缓存位置：<code>~/.cache/vmware/drag_and_drop</code><br>删除：<code>rm -rf ~/.cache/vmware/drag_and_drop</code></p><p>修改虚拟机名称 : <code>nano /etc/hostname</code></p><p>添加root用户 : <code>sudo passwd root</code></p><p>更新kali下载源 : <code>apt update</code> </p><p>解压 : <code>tar zxvf .zip </code>   <code>7z x .zip</code>  </p><p>切换python版本 : <code>pyenv local 3.8.0</code></p><p>window校验 : <code>CertUtil -hashfile 压缩包 算法(大写)</code></p><p>linux校验 : <code>md5sum 压缩包</code></p><p>查询命令 : <code>history  |grep  </code></p><h1 id="科学"><a href="#科学" class="headerlink" title="科学"></a>科学</h1><p>clash下载地址：<a href="https://github.com/Dreamacro/clash/releases">https://github.com/Dreamacro/clash/releases</a></p><p>解压：gunzip  文件</p><p>权限：chmod 777</p><p>然后运行就可以</p><p>配置文件在~/.config/clash/config.yaml，里面写上订阅地址的内容</p><h1 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h1><p>frida命令行参数</p><p>-U : usb,也就是adb</p><p>-F : 最前台的应用</p><p> -l : 加载脚本</p><p>-p :指定pid,attach</p><p>-C : 在c里面写和调用frida的api</p><p>-e : 直接执行这个命令</p><p>–no-pause : 启动进程</p><p>-o : 把输出执行到一个文件</p><p>两种操作Frida模式</p><ol><li><p>命令 : spwan(进程创建的时候注入) , attach(附加注入)</p></li><li><p>RPC :  用python调用</p></li></ol><p>Frida两种操作APP模式</p><p>SPAWN：创建进程时就hook：有壳的话就不行<br>ATTACH：应用运行过程中hook：有壳也是ok</p><ol><li><p>spwan : frida -U -f 包名 -l  js文件  –no-pause   </p></li><li><p>attach : <strong>frida -UF -l js文件</strong> , 要使用v8运行 –runtime=v8 , Script.runtime , 保存</p></li></ol><h2 id="Objection"><a href="#Objection" class="headerlink" title="Objection"></a>Objection</h2><p>启动 : objection -g 包名 explore</p><p>启动时hook : objection -g 包名 explore –startup-command “android hooking watch class java类”  //引号里面是hook代码</p><p>hook到关键类的时候用<strong>class_method</strong>来hook参数 返回值 调用栈 </p><p>cat objection.log |grep com.类  //运行过的类才会出现在objection.log ,日志在~/.objection/文件夹里</p><h3 id="Wallbreaker"><a href="#Wallbreaker" class="headerlink" title="Wallbreaker"></a>Wallbreaker</h3><p>加载 : <code>plugin load /root/Desktop/Wallbreaker</code></p><p><code>plugin wallbreaker classdump --fullname com.ilulutv.fulao2.film.k.d</code></p><h2 id="ZenTrace"><a href="#ZenTrace" class="headerlink" title="ZenTrace"></a>ZenTrace</h2><h1 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h1><h2 id="OkHttpLogger-Frida"><a href="#OkHttpLogger-Frida" class="headerlink" title="OkHttpLogger-Frida"></a>OkHttpLogger-Frida</h2><p>解okhttp的混淆</p><p>github地址:<a href="https://github.com/lingade/OkHttpLogger-Frida">https://github.com/lingade/OkHttpLogger-Frida</a></p><ol><li><p>首先将 <code>okhttpfind.dex</code> 拷贝到 <code>/data/local/tmp/</code> 目录下</p></li><li><p>启动 : <code>frida -U -l okhttp_poker.js -f com.example.demo --no-pause</code></p></li><li><p>pyhton版本用3.8.0,frida版本用12.8.0,<code>find()</code>开始寻找被混淆后的类</p></li><li><p>hold()开启hook拦截,手机里面进行操作</p></li></ol><h2 id="frida-ssl-logger"><a href="#frida-ssl-logger" class="headerlink" title="frida_ssl_logger"></a>frida_ssl_logger</h2><p>github地址:<a href="https://github.com/TTDemo/frida_ssl_logger">https://github.com/TTDemo/frida_ssl_logger</a></p><p>安装hexdump <code>pip install hexdump</code></p><p>到目录后启动 : <code>python3 ./ssl_logger.py  -U -f com.bfc.mm</code></p><p>导出文本启动 : <code>python3 ./ssl_logger.py  -U -f com.bfc.mm &gt;&gt; mz.txt</code></p><h1 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h1><h2 id="frida-dexdump"><a href="#frida-dexdump" class="headerlink" title="frida-dexdump"></a>frida-dexdump</h2><p>1.进入frida_dexdump目录,python main.py 开始脱壳</p><p>2.搜索dex文件:grep -ril  “MainActivity”</p><p>du -h *  //查看dex大小</p><h2 id="frida-fart"><a href="#frida-fart" class="headerlink" title="frida-fart"></a>frida-fart</h2><p><strong>frida_fart_hook.js是只能8系统的手机运行</strong></p><p><strong>du -h *  //查看dex大小</strong></p><p>1.把lib里面的两个so文件传到手机 /data/app/目录里面</p><p>2.不能直接传进去就传到/data/local/tmp里面然后移动到/data/app里,移动:cp fart* /data/app/</p><p>3.赋予权限:chmod 777 fart*</p><p>4.新建文件夹储存dex,在js里面也改好对应的目录,mkdir 文件夹名字 </p><p>5.启动:frida -U -f 包名 -l  js文件 –no-pause  //–no-pause这个是启动进程</p><p>6.dex导出到电脑:adb pull 手机存储的目录</p><p>7.搜索dex文件:grep -ril “LoginActivity”</p><h1 id="AOSP"><a href="#AOSP" class="headerlink" title="AOSP"></a>AOSP</h1><p>setopt shwordsplit</p><h2 id="1-设置硬盘"><a href="#1-设置硬盘" class="headerlink" title="1.设置硬盘"></a>1.设置硬盘</h2><p>Gparted //应用,磁盘的管理</p><p>df -h 查看</p><p>fdisk -l 可以看见磁盘容量变成了我们设置的</p><p>桌面创建文件夹 : <code>mkdir OMPILE</code>  </p><p>硬盘移动到文件夹里  : <code>mount /dev/sda3 COMPILE</code>  </p><p>回退到bash : <code>chsh -s /bin/bash</code></p><h2 id="2-AOSP系统"><a href="#2-AOSP系统" class="headerlink" title="2.AOSP系统"></a>2.AOSP系统</h2><p>解压asop8.1,7z解压途中有一个选择,选a</p><h2 id="3-下载驱动"><a href="#3-下载驱动" class="headerlink" title="3.下载驱动"></a>3.下载驱动</h2><p><a href="https://developers.google.com/android/drivers">https://developers.google.com/android/drivers</a></p><p>解压到asop文件夹里面如何运行,选择I ACCEPT即可</p><h2 id="4-编译环境"><a href="#4-编译环境" class="headerlink" title="4.编译环境"></a>4.编译环境</h2><h3 id="准备编译环境"><a href="#准备编译环境" class="headerlink" title="准备编译环境"></a>准备编译环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># apt update</span><br><span class="line"># git config --global user.email &quot;you@example.com&quot;</span><br><span class="line"># git config --global user.name &quot;Your Name&quot;</span><br><span class="line"># apt install bison tree</span><br><span class="line"># dpkg --add-architecture i386</span><br><span class="line"># apt update</span><br><span class="line"># apt install libc6:i386 libncurses5:i386 libstdc++6:i386 libxml2-utils</span><br></pre></td></tr></table></figure><h3 id="openjdk8"><a href="#openjdk8" class="headerlink" title="openjdk8"></a>openjdk8</h3><blockquote><p>一定要注意目录位置</p></blockquote><p>aosp8.1.0源码编译的时候，需要openjdk8，其实源码中就带openjdk8了，可以这样设置一下即可：</p><p><code>update-alternatives --install /usr/bin/java java /root/Desktop/COMPILE/aosp810r1/prebuilts/jdk/jdk8/linux-x86/bin/java 1</code></p><p><code>update-alternatives --install /usr/bin/javac javac /root/Desktop/COMPILE/aosp810r1/prebuilts/jdk/jdk8/linux-x86/bin/javac 1</code></p><p><code>update-alternatives --set java /root/Desktop/COMPILE/aosp810r1/prebuilts/jdk/jdk8/linux-x86/bin/java</code></p><p><code>update-alternatives --set javac /root/Desktop/COMPILE/aosp810r1/prebuilts/jdk/jdk8/linux-x86/bin/javac</code></p><p><code>update-alternatives --install /usr/bin/javadoc javadoc /root/Desktop/COMPILE/aosp810r1/prebuilts/jdk/jdk8/linux-x86/bin/javadoc 1</code></p><p><code>update-alternatives --set javadoc /root/Desktop/COMPILE/aosp810r1/prebuilts/jdk/jdk8/linux-x86/bin/javadoc</code></p><p>在~/.bashrc当中配置JAVA_HOME<br><code>export JAVA_HOME=/root/Desktop/COMPILE/aosp810r1/prebuilts/jdk/jdk8/linux-x86/; export PATH=$PATH:$HOME/bin:$JAVA_HOME/bin;</code></p><p>然后<code>source ~/.bashrc</code></p><p><code>java -version</code></p><h2 id="5-开始编译"><a href="#5-开始编译" class="headerlink" title="5.开始编译"></a>5.开始编译</h2><p>aosp目录下 运行: <code>source build/envsetup.sh</code></p><p>选择lunch</p><p>之后运行 : <code>export LC_ALL=C</code></p><p>清除make之前的数据 (第一次无需): <code>make clean</code> </p><p>编译的结果在: out/target/product/sailfish</p><p>把结果里面的image搞到镜像包里面的image压缩包里</p><h2 id="附加swap"><a href="#附加swap" class="headerlink" title="附加swap"></a>附加swap</h2><p>磁盘目录</p><p>增加10G分区 : <code>dd if=/dev/zero of=swapfile bs=1024 count=10240000</code></p><p>把分区变成swap分区 :<code>mkswap swapfile</code></p><p>使用这个swap分区,确认有效状态 : <code>swapon swapfile</code></p><h1 id="WXappid"><a href="#WXappid" class="headerlink" title="WXappid"></a>WXappid</h1><p><strong>com.tencent.mm.opensdk.openapi.WXAPIFactory</strong>的<strong>createWXAPI</strong>方法<br>  public static IWXAPI createWXAPI(Context context, String str, boolean z) {<br>     String str2 = TAG;<br>     StringBuilder sb = new StringBuilder(“createWXAPI, appId = “);<br>     sb.append(str);<br>     sb.append(“, checkSignature = “);<br>     sb.append(z);<br>     Log.d(str2, sb.toString());<br>     return new WXApiImplV10(context, str, z);<br>  }</p><h1 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h1><h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><p>用户目录 : /data/misc/user/0/</p><p>系统目录 : /system/etc/security/cacerts</p>]]></content>
      
      
      <categories>
          
          <category> 安卓逆向 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>solidity笔记</title>
      <link href="/2022/03/08/solidity%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/08/solidity%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>solidity是静态类型的语言,定义类型之后不能随便更改,比如整数型就不能改成文本型</p></blockquote><h1 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h1><h2 id="布尔类型-Bolleans"><a href="#布尔类型-Bolleans" class="headerlink" title="布尔类型(Bolleans)"></a>布尔类型(Bolleans)</h2><ul><li><p>关键字 : bool</p></li><li><p>值 : true/false</p></li></ul><h2 id="整型-Integers"><a href="#整型-Integers" class="headerlink" title="整型(Integers)"></a>整型(Integers)</h2><blockquote><p>使用整型时,要特别注意整型的大小及所能容纳的最大值和最小值(整型溢出)</p></blockquote><ul><li>int : int8 int16 … int256 (8个字节 16个字节这样,可以存小于0)</li><li>uint : uint8 … uint256(u:unsinged无符号,只能存大于0)</li><li>/(除)会有截断,例:5/2=2,除0会抛异常</li><li>x&lt;&lt;y和乘等价,左移一位相当于乘2</li><li>x&gt;&gt;y和除等价,右移一位相当于除2</li></ul><h2 id="定长浮点型-Fixed-Point-Numbers"><a href="#定长浮点型-Fixed-Point-Numbers" class="headerlink" title="定长浮点型(Fixed Point Numbers)"></a>定长浮点型(Fixed Point Numbers)</h2><ul><li><p>fixed / ufixed (类似其他语言的浮点型float / double)</p></li><li><p>fixedMxN  ufixedMxN(定义的时候就确认好位数,例:fixed<code>32</code>x<code>3</code> )</p></li><li><p>M : 所占空间的位数(以8步进,可为8到256位)</p></li><li><p>N:小数点的位数(可为0到80之间)</p></li></ul><h2 id="定长字节数组-Fixed-size-byte-arrays"><a href="#定长字节数组-Fixed-size-byte-arrays" class="headerlink" title="定长字节数组(Fixed-size byte arrays)"></a>定长字节数组(Fixed-size byte arrays)</h2><ul><li>占空间固定的数组,例:bytes1 bytes2 bytes3 … bytes32(表示所占空间的字节数)</li><li>byte 等价于bytes1</li><li>.length 返回字节数组长度</li><li>可以像字符串一样去使用  bytes3 bt= “abc”</li><li>可以像整型一样比较运算和位运算</li><li>可以像数组一样进行索引 bytes3 bt= “abc”, bt[1] 就是等于b</li></ul><h2 id="数字-有理数和整数-常量-Rational-and-Integer-Literals"><a href="#数字-有理数和整数-常量-Rational-and-Integer-Literals" class="headerlink" title="数字(有理数和整数)常量(Rational and Integer Literals)"></a>数字(有理数和整数)常量(Rational and Integer Literals)</h2><ul><li><p>表达式中直接出现的数字</p></li><li><p>表达式中不会发生截断和溢出</p></li></ul><h2 id="字符串常量-String-literals"><a href="#字符串常量-String-literals" class="headerlink" title="字符串常量(String literals)"></a>字符串常量(String literals)</h2><ul><li><p>表达式中直接出现的字符串</p></li><li><p>支持转义 : \n(换行符)   \x61(‘a’ ASCII)   \u718A(‘熊’ Unicode)</p></li><li><p>字符串常量不支持任何运算,如字符串拼接</p></li></ul><h2 id="十六进制常量-Hexadecimal-Literal"><a href="#十六进制常量-Hexadecimal-Literal" class="headerlink" title="十六进制常量(Hexadecimal Literal)"></a>十六进制常量(Hexadecimal Literal)</h2><ul><li>表达式中直接出现的字符串:内容是16进制数</li><li>写法 : hex”001122ff”</li></ul><h2 id="枚举-Enums"><a href="#枚举-Enums" class="headerlink" title="枚举(Enums)"></a>枚举(Enums)</h2><ul><li>关键字<code>enum</code>用来自定义类型</li><li>可与整数进行转换(强制转换),但不能进行隐式转换</li><li>枚举类型应至少有一名成员</li><li>强制转换:unit(变量)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//使用枚举自定义一个类型ActionChoices的变量</span><br><span class="line">enum ActionChoices(参数1,参数2,参数3,参数4)</span><br><span class="line">//定义一个ActionChoices变量</span><br><span class="line">ActionChoices a ;</span><br></pre></td></tr></table></figure></li></ul><h2 id="地址类型-Address"><a href="#地址类型-Address" class="headerlink" title="地址类型(Address)"></a>地址类型(Address)</h2><ul><li>address : 表示一个账户地址(20字节)</li><li>地址.balance 获取到地址的余额,单位是wei</li><li>transfer()和send()都有2300gas的限制  </li><li>call(函数签名,参数)可以调用其他合约的函数</li><li>call可以指定value和gas,例如call.value().gas()(函数签名,参数)</li><li>delegatecall()和call()是一样的,只不过不可以指定value</li><li>delegatecall()和call()区别是delegatecall只能调用当前合约的,call可以调用不同合约</li></ul><p>call和delegatecall是底层代码,失败不会报异常,可以用require(address.call())包起来,这样失败就会报异常</p><h2 id="函数类型-Function-Types"><a href="#函数类型-Function-Types" class="headerlink" title="函数类型(Function Types)"></a>函数类型(Function Types)</h2><ul><li>函数是一种类型<ul><li>函数类型可以作为变量类型,也可以作为返回值类型</li></ul></li><li>两种函数类型<ul><li>外部(<code>external</code>)函数 : 发起EVM消息调用,使用: 地址.函数名 进行调用</li><li>内部(<code>internal</code>)函数 : 代码跳转调用,gas小的多,但无法的合约外部调用,使用函数名进行调用</li><li>默认是内部函数调用</li></ul></li><li>声明 <ul><li>声明函数 function foo(int) external returns (int){}</li><li>声明函数变量 function foo(int) external returns (int) foo;</li></ul></li><li>成员.selector属性,返回函数选择器(MethodID),<code>内部函数没有这个属性</code></li></ul><h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><h2 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h2><ul><li>storage(区块链中)<ul><li>状态变量</li><li>复杂类型的局部变量</li></ul></li><li>memory(EVM内存中)<ul><li>局部变量及参数</li></ul></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>声明T[k]<ul><li>T:元素类型,k:数组长度(可选) 例如:uint[10] a;</li><li>uint[] public u = [1,2,3];public数组状态变量会自动生成一个对应变量的函数</li></ul></li><li>使用new关键字<ul><li>uint[] c = new uint<a href="7"></a>;  //代表7个数组长度,uint[7]的意思</li></ul></li><li>成员<ul><li>.length</li><li>.push()</li></ul></li></ul><h2 id="字节数组"><a href="#字节数组" class="headerlink" title="字节数组"></a>字节数组</h2><ul><li>字节数组bytes,类似byte[],不过bytes作为外部函数的参数时空间更小</li></ul><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><ul><li>关键字mapping</li><li>mapping(address =&gt; uint) public balances  //会生成对应的函数,代码意思就是查询地址余额</li><li>address是键类型,uint是值类型,键类型不能是变长数组 合约类型 嵌套类型,值类型无限制</li><li>局限性<ul><li>只能作为状态变量</li><li>无法遍历访问(没有长度,没有键集合,没有值集合)</li></ul></li></ul><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><ul><li><p>关键字struct自定义类型</p></li><li><p>结构体内可以定义基本类型,数组,映射,不可以包含自己,但可以在映射里面调用自己</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">错误写法:</span><br><span class="line">struct 结构体名字&#123;</span><br><span class="line">    bool 变量名;</span><br><span class="line">    uint 变量名;</span><br><span class="line">    结构体名字 变量名;</span><br><span class="line">&#125;</span><br><span class="line">正确写法:</span><br><span class="line">struct 结构体名字&#123;</span><br><span class="line">    bool 变量名;</span><br><span class="line">    uint 变量名;</span><br><span class="line">    mapping(string=&gt;结构体名字)变量名;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>声明与初始化</p><ul><li><p>仅声明变量,不初始化可以这么写:结构体名字  aaa;</p></li><li><p>按成员顺序初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//结构体名字:CustomType</span><br><span class="line">CustomType ct1 = CustomType(true,2)</span><br><span class="line">//结构体名字:Type3</span><br><span class="line">struct Type3&#123;</span><br><span class="line">    string name;</span><br><span class="line">    mapping(string=&gt;uint)score;</span><br><span class="line">    int age;</span><br><span class="line">&#125;</span><br><span class="line">Type3 ct = Type3(&quot;tiny&quot;,2);//跳过对mapping的初始化</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><ul><li>重置变量</li><li>对映射无效</li><li>不影响值拷贝的变量</li></ul><h2 id="时间及日期"><a href="#时间及日期" class="headerlink" title="时间及日期"></a>时间及日期</h2><ul><li><p>时间单位</p><ul><li>seconds(秒)</li><li>minutes(分)</li><li>hours(时)</li><li>days(天)</li><li>weeks(星期)</li><li>years(年)</li></ul></li><li><p>获取当前时间 : now;</p></li></ul><h2 id="ABI编码函数"><a href="#ABI编码函数" class="headerlink" title="ABI编码函数"></a>ABI编码函数</h2><ul><li>abi.encode(…) returns(bytes):计算参数的ABI编码(每个参数64位)</li><li>abi.encodePacked(…) returns(bytes):计算参数的紧密打包编码</li><li>abi.encodeWithSelector(bytes4 selector,…)returns (bytes):计算函数选择器和参数的ABI编码</li><li>abi.encodeWithSignature(string signature,…)returns(bytes):等价于abi.encodeWithSelector(bytes4(keccak256(signature)),…),(input数据)</li></ul><h1 id="错误处理函数"><a href="#错误处理函数" class="headerlink" title="错误处理函数"></a>错误处理函数</h1><ul><li>assert(bool condition)用于判断内部错误,条件不满足时抛出异常<ul><li>下标(序号)越界</li><li>被除数为0,如5/0 或 23%0</li><li>负移位.如:5&lt;&lt;i;i为-1时</li><li>过大整数或负值转为枚举类型,则抛出异常</li><li>调用未初始化内部函数类型的变量</li><li>调用assert参数为false</li><li>…</li><li>报错后消耗剩余的gas</li></ul></li><li>require(bool condition)用于判断输入或外部组件错误,条件不满足时抛出异常<ul><li>调用throw</li><li>调用require的参数为false</li><li>外部函数调用 消息调用 出错</li><li>没有payable的public的函数接收以太币时</li><li>如果.transfer()执行失败</li><li>…</li><li>require是外部条件异常,剩余gas会返还给调用者</li></ul></li><li>require(bool condition,string message) 同上,多了一个错误信息</li><li>revert()终止执行并还原改变的状态</li><li>revert(string reason)同上,提供一个错误信息</li></ul><h1 id="函数修改器"><a href="#函数修改器" class="headerlink" title="函数修改器"></a>函数修改器</h1><ul><li><p>modifier关键字定义函数修改器</p><ul><li><p>函数修改器可以用来改变一个函数的行为,通常用于在函数执行时检查某种前置条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">modifier onlyOwner&#123;</span><br><span class="line">require(msg.sender == owner);</span><br><span class="line">    _;</span><br><span class="line">&#125;</span><br><span class="line">function kill public onlyOwner&#123;</span><br><span class="line">    //do somethind</span><br><span class="line">&#125;</span><br><span class="line">函数修改器修饰函数时,函数体被插入到&quot;_;&quot;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>函数修改器可以被继承使用</p></li><li><p>函数修改器可接受参数</p></li><li><p>多个函数修改器一起使用</p><ul><li>空格隔开,修改器会一次检查执行</li></ul></li><li><p>理解函数修改器执行流</p><ul><li>在修改器中函数内return语句,仅仅跳出当前的修改器或函数,”_”后继续执行</li></ul></li><li><p>函数修改器有防止递归的功能</p></li></ul><h1 id="函数修饰符"><a href="#函数修饰符" class="headerlink" title="函数修饰符"></a>函数修饰符</h1><ul><li>payable 表示一个函数能附加以太币的调用</li><li>view 表示一个函数不能修改状态<ul><li>view和constant等价,constant在0.5版本之后会弃用</li><li>本地执行不消耗gas</li></ul></li><li>pure 表示一个函数不读取状态,也不修改状态<ul><li>本地执行不消耗gas</li></ul></li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul><li><p>继承的合约可以访问所有非private成员</p><ul><li>external(外部访问)</li><li>public(内/外访问)</li><li>internal(内部及继承访问)</li><li>private(内部访问)</li></ul></li><li><p>is表示继承,通过复制代码的方式实现继承</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">contract A&#123;&#125;</span><br><span class="line">contract B is A&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造函数:派生合约需要调用父合约的构造函数,如果有参数,派生合约需要提供参数<code>调用父合约构造函数</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">contract Base&#123;</span><br><span class="line">    //构造函数</span><br><span class="line">    constructor(uint _a)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//第一种方法</span><br><span class="line">contract Derived1 is Base(7)&#123;&#125;</span><br><span class="line">//第二种方法</span><br><span class="line">contract Derived2 is Base&#123;</span><br><span class="line">    constructor(uint _y)Base(_y * _y) public&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多重继承</p><ul><li><p>is后接多个合约,基类合约在is后的顺序很重要</p></li><li><p>继承顺序原则是冲最接近基类到最接近派生类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract X&#123;&#125;</span><br><span class="line">contract A is X&#123;&#125;</span><br><span class="line">contract C is A,X&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>抽象合约 interface </p><ul><li>合约存在没有函数体(实现)的函数</li><li>合约不能通过编译,只能被继承</li></ul></li><li><p>接口</p><ul><li>没有任何函数是已实现的</li><li>函数不能继承其他合约或接口</li><li>不能定义构造器 变量 结构体 枚举类</li></ul></li></ul><h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1><ul><li><p>一个特殊的合约:可以像合约一样进行部署,但没有状态变量,不能存以太币</p></li><li><p>可重用</p><ul><li>部署一次,可在不同合约内反复使用</li><li>节约gas,相同功能的代码不用部署一遍又一遍</li></ul></li><li><p>using for 扩展类型</p><ul><li>using A for B 把库函数(从库A)关联到类型B</li><li>A库有函数add(B b),泽可使用b.add()</li></ul></li></ul><h1 id="回退函数-Fallback"><a href="#回退函数-Fallback" class="headerlink" title="回退函数(Fallback)"></a>回退函数(Fallback)</h1><ul><li>无名称 无参数 无返回值 函数<ul><li>一个合约可以有一个回退函数</li><li>当给合约转以太币时,需要有payable回退函数</li><li>如果调用合约时,没有匹配上任何函数,就会调用回退函数</li></ul></li></ul><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><ul><li><p>如何理解事件</p><ul><li>外部获取智能合约的状态变化</li><li>事件其实是以太坊日志接口,可索引</li></ul></li><li><p>如何使用</p><ul><li>声明事件,可继承 : event EventName(uint param)</li><li>发出一个事件 : emit EventName(10)</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建</title>
      <link href="/2022/03/08/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/03/08/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p><code>npm install hexo</code></p><h1 id="初始化博客文件"><a href="#初始化博客文件" class="headerlink" title="初始化博客文件"></a>初始化博客文件</h1><p>创建博客 : <code>hexo init blog(文件夹名)</code></p><p><code>cd blog</code>后下载依赖包<code>npm install</code></p><h1 id="设置SSH公钥"><a href="#设置SSH公钥" class="headerlink" title="设置SSH公钥"></a>设置SSH公钥</h1><p>设置Git信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="variable language_">global</span> user.<span class="property">name</span> <span class="string">&quot;github名称&quot;</span> </span><br><span class="line">git config --<span class="variable language_">global</span> user.<span class="property">email</span> <span class="string">&quot;github邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>生成ssh : <code>shh-keygen -t rsa -C &quot;github邮箱&quot;</code></p><p>生成后在c盘用户目录下会有.ssh文件夹,打开里面<code>id_rsa.pub</code>的文件,全选复制后设置github里的SSH</p><p><img src="https://cdn.jsdelivr.net/gh/yunqihaodianer/picgo/img/20220308174159.png"></p><p>测试ssh是否绑定成功 : <code>ssh -T git@github.com</code></p><h1 id="发布博饼到Github"><a href="#发布博饼到Github" class="headerlink" title="发布博饼到Github"></a>发布博饼到Github</h1><p>Github创建仓库,仓库名 : <code>github名.github.io</code></p><p>设置博客文件夹里的_config.yml文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">&#x27;Github仓库地址&#x27;</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><p>安装插件 : <code>npm install hexo-deployer-git --save</code></p><p>清理Hexo缓存 : <code>hexo clean</code></p><p>生成文件 : <code>hexo g</code></p><p>上传Github仓库 : <code>hexo d</code></p><h1 id="Git版本管理"><a href="#Git版本管理" class="headerlink" title="Git版本管理"></a>Git版本管理</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https://github.com/yunqihaodianer/blog.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
